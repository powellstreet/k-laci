{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///Users/jincheoljuhn/Desktop/Projects/k-laci/k-lacl-fe/k-laci/atoms/charts/RadarChart.tsx"],"sourcesContent":["import React from 'react';\n\ntype GradientType =\n  | 'radial-center-to-edge'\n  | 'radial-edge-to-center'\n  | 'linear-base-to-center'\n  | 'linear-center-to-base';\n\ntype ColorDefinition = {\n  startColor: string;\n  endColor: string;\n  gradientType: GradientType;\n};\n\ntype Props = {\n  data: number[]; // [0~100] 값 8개 (기대값)\n  labels?: string[]; // 항목 라벨 8개\n  showGrid?: boolean; // 레이더 원 표시 여부\n};\n\nconst JewelRadarChart = ({ data, labels, showGrid = false }: Props) => {\n  const size = 500;\n  const center = size / 2;\n  const radius = 200;\n\n  // 항목 수를 8개로 고정하거나 props.labels 길이에 맞춤\n  const categories = labels || [\n    '경제혁신형',\n    '생활역동형',\n    '안전복원형',\n    '인구성장형',\n    '경제정속형',\n    '생활정주형',\n    '안전정진형',\n    '새로운항목', // 8번째 항목 추가 (혹은 실제 라벨 사용)\n  ];\n\n  const numAxes = categories.length; // 이제 8이 됩니다.\n  const angleStep = (2 * Math.PI) / numAxes;\n\n  // **핵심 수정: data 배열 길이 보정**\n  // data 배열의 길이가 numAxes보다 짧으면 0으로 채워서 오류 방지\n  const processedData = [...data];\n  while (processedData.length < numAxes) {\n    processedData.push(0); // 부족한 데이터는 0으로 채움\n  }\n\n  // ⭕️ 점 좌표 계산 - 이제 processedData를 사용합니다.\n  const points = processedData.map((value, i) => {\n    const angle = -Math.PI / 2 + i * angleStep;\n    const r = (value / 100) * radius;\n    return {\n      x: center + r * Math.cos(angle),\n      y: center + r * Math.sin(angle),\n    };\n  });\n\n  // 🎨 각 삼각형의 시작색 → 끝색 정의 및 그라데이션 타입 지정\n  // 8번째 항목에 대한 색상 정의 추가\n  const fixedColorDefinitions: ColorDefinition[] = [\n    // [0] 경제혁신형: 빨강 → 초록\n    {\n      startColor: '#F56542',\n      endColor: '#C2BDF3',\n      gradientType: 'radial-center-to-edge',\n    },\n    // [1] 생활역동형: 초록 → 노랑\n    {\n      startColor: '#F56542',\n      endColor: '#FFFF00',\n      gradientType: 'linear-base-to-center',\n    },\n    // [2] 안전복원형: 보라 → 노랑\n    {\n      startColor: '#800080',\n      endColor: '#FFFF00',\n      gradientType: 'radial-edge-to-center',\n    },\n    // [3] 인구성장형: 파랑 → 주황\n    {\n      startColor: '#0000FF',\n      endColor: '#C2BDF3',\n      gradientType: 'linear-center-to-base',\n    },\n    // [4] 경제정속형: 시안(청록) → 마젠타(자홍)\n    {\n      startColor: '#00FFFF',\n      endColor: '#FF00FF',\n      gradientType: 'radial-center-to-edge',\n    },\n    // [5] 생활정주형: 주황 → 파랑\n    {\n      startColor: '#FFA500',\n      endColor: '#0000FF',\n      gradientType: 'linear-base-to-center',\n    },\n    // [6] 안전정진형: 마젠타(자홍) → 초록\n    {\n      startColor: '#FF00FF',\n      endColor: '#74BF9E',\n      gradientType: 'radial-edge-to-center',\n    },\n    // [7] 새로운항목: 연한 파랑 → 진한 파랑 (8번째 항목 추가)\n    {\n      startColor: '#87CEEB',\n      endColor: '#4169E1',\n      gradientType: 'linear-center-to-base',\n    },\n  ];\n\n  // 레이더 차트의 외곽선을 정의하는 clipPath\n  // points 배열이 항상 numAxes 길이를 가지므로 안전합니다.\n  const radarOutlinePath =\n    points.map((p, idx) => `${idx === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ') +\n    'Z';\n\n  return (\n    <svg width={size} height={size}>\n      <defs>\n        {/* 각 삼각형에 적용될 다양한 타입의 그라데이션 정의 */}\n        {points.map((point, i) => {\n          // 이제 points는 항상 numAxes 길이를 가짐\n          const { startColor, endColor, gradientType } =\n            fixedColorDefinitions[i % fixedColorDefinitions.length];\n          const nextPoint = points[(i + 1) % numAxes]; // nextPoint도 항상 정의됨\n\n          const baseMidX = (point.x + nextPoint.x) / 2;\n          const baseMidY = (point.y + nextPoint.y) / 2;\n\n          const opaqueStartOpacity = 0.8;\n          const opaqueEndOpacity = 1.0;\n\n          if (gradientType === 'radial-center-to-edge') {\n            return (\n              <radialGradient\n                key={i}\n                id={`grad${i}`}\n                cx={center}\n                cy={center}\n                r={radius}\n                fx={center}\n                fy={center}\n                gradientUnits=\"userSpaceOnUse\"\n              >\n                <stop\n                  offset=\"0%\"\n                  stopColor={startColor}\n                  stopOpacity={opaqueStartOpacity}\n                />\n                <stop\n                  offset=\"100%\"\n                  stopColor={endColor}\n                  stopOpacity={opaqueEndOpacity}\n                />\n              </radialGradient>\n            );\n          } else if (gradientType === 'radial-edge-to-center') {\n            return (\n              <radialGradient\n                key={i}\n                id={`grad${i}`}\n                cx={center}\n                cy={center}\n                r={radius}\n                fx={center}\n                fy={center}\n                gradientUnits=\"userSpaceOnUse\"\n              >\n                <stop\n                  offset=\"0%\"\n                  stopColor={endColor}\n                  stopOpacity={opaqueEndOpacity}\n                />\n                <stop\n                  offset=\"100%\"\n                  stopColor={startColor}\n                  stopOpacity={opaqueStartOpacity}\n                />\n              </radialGradient>\n            );\n          } else if (gradientType === 'linear-base-to-center') {\n            return (\n              <linearGradient\n                key={i}\n                id={`grad${i}`}\n                x1={baseMidX}\n                y1={baseMidY}\n                x2={center}\n                y2={center}\n                gradientUnits=\"userSpaceOnUse\"\n              >\n                <stop\n                  offset=\"0%\"\n                  stopColor={endColor}\n                  stopOpacity={opaqueEndOpacity}\n                />\n                <stop\n                  offset=\"100%\"\n                  stopColor={startColor}\n                  stopOpacity={opaqueStartOpacity}\n                />\n              </linearGradient>\n            );\n          } else if (gradientType === 'linear-center-to-base') {\n            return (\n              <linearGradient\n                key={i}\n                id={`grad${i}`}\n                x1={center}\n                y1={center}\n                x2={baseMidX}\n                y2={baseMidY}\n                gradientUnits=\"userSpaceOnUse\"\n              >\n                <stop\n                  offset=\"0%\"\n                  stopColor={startColor}\n                  stopOpacity={opaqueStartOpacity}\n                />\n                <stop\n                  offset=\"100%\"\n                  stopColor={endColor}\n                  stopOpacity={opaqueEndOpacity}\n                />\n              </linearGradient>\n            );\n          }\n          return null;\n        })}\n\n        {/* 블렌딩 효과를 위한 SVG 필터 정의 */}\n        <filter\n          id=\"blendingFilter\"\n          x=\"-50%\"\n          y=\"-50%\"\n          width=\"200%\"\n          height=\"200%\"\n        >\n          <feGaussianBlur\n            in=\"SourceGraphic\"\n            stdDeviation=\"25\"\n            result=\"blurred\"\n          />\n          <feBlend in=\"SourceGraphic\" in2=\"blurred\" mode=\"screen\" />\n        </filter>\n\n        {/* clipPath 적용: 이제 <g>에 적용될 것입니다. */}\n        <clipPath id=\"radarClipPath\">\n          <path d={radarOutlinePath} />\n        </clipPath>\n      </defs>\n\n      {/* 💎 보석 삼각형 조각들을 그룹으로 묶고 필터와 clipPath 적용 */}\n      {/* clipPath=\"url(#radarClipPath)\"가 이제 <g>에 적용됩니다. */}\n      <g filter=\"url(#blendingFilter)\" clipPath=\"url(#radarClipPath)\">\n        {points.map((point, i) => {\n          const next = points[(i + 1) % numAxes];\n          return (\n            <path\n              key={i}\n              d={`M${center},${center} L${point.x},${point.y} L${next.x},${next.y} Z`}\n              fill={`url(#grad${i})`}\n              fillOpacity={1.0}\n            />\n          );\n        })}\n      </g>\n\n      {/* 🌀 격자 원 */}\n      {showGrid &&\n        [0.25, 0.5, 0.75, 1.0].map((ratio, i) => (\n          <circle\n            key={`grid-${i}`}\n            cx={center}\n            cy={center}\n            r={radius * ratio}\n            fill=\"none\"\n            stroke=\"#6c676746\"\n            strokeWidth={0.5}\n          />\n        ))}\n\n      {/* ⚪ 방사형 축 */}\n      {showGrid &&\n        categories.map((_, i) => {\n          const angle = -Math.PI / 2 + i * angleStep;\n          const x = center + radius * Math.cos(angle);\n          const y = center + radius * Math.sin(angle);\n\n          return (\n            <line\n              key={`axis-${i}`}\n              x1={center}\n              y1={center}\n              y2={y}\n              x2={x}\n              stroke=\"#ccc\"\n              strokeWidth={0.5}\n            />\n          );\n        })}\n\n      {/* 🏷️ 라벨 */}\n      {categories.map((label, i) => {\n        const angle = -Math.PI / 2 + i * angleStep;\n        const x = center + (radius + 20) * Math.cos(angle);\n        const y = center + (radius + 20) * Math.sin(angle);\n\n        let textAnchor = 'middle';\n        let dy = '0.35em';\n\n        // 8개 항목에 맞춰 라벨 위치 조정 로직 재검토 (필요 시)\n        // 현재 로직은 모든 각도에 대해 작동하지만, 8개 항목에서 라벨이 겹치지 않도록\n        // 미세 조정이 필요할 수 있습니다.\n        if (Math.abs(Math.cos(angle)) > 0.8) {\n          // 수평에 가까운 축 (0도, 180도)\n          textAnchor = Math.cos(angle) > 0 ? 'start' : 'end';\n          dy = '0.35em';\n        } else if (Math.abs(Math.sin(angle)) > 0.8) {\n          // 수직에 가까운 축 (90도, 270도)\n          textAnchor = 'middle';\n          dy = Math.sin(angle) > 0 ? '1em' : '-0.3em';\n        } else {\n          // 대각선 축\n          if (Math.cos(angle) > 0 && Math.sin(angle) < 0) {\n            // 우상단 (45도)\n            textAnchor = 'start';\n            dy = '-0.3em';\n          } else if (Math.cos(angle) < 0 && Math.sin(angle) < 0) {\n            // 좌상단 (135도)\n            textAnchor = 'end';\n            dy = '-0.3em';\n          } else if (Math.cos(angle) < 0 && Math.sin(angle) > 0) {\n            // 좌하단 (225도)\n            textAnchor = 'end';\n            dy = '1em';\n          } else if (Math.cos(angle) > 0 && Math.sin(angle) > 0) {\n            // 우하단 (315도)\n            textAnchor = 'start';\n            dy = '1em';\n          }\n        }\n\n        return (\n          <text\n            key={`label-${i}`}\n            x={x}\n            y={y}\n            textAnchor={textAnchor}\n            dy={dy}\n            fontSize=\"12\"\n            fill=\"#444\"\n          >\n            {label}\n          </text>\n        );\n      })}\n\n      {/* 방사선 값 표기 (0 ~ 100, 20 단위, 십자형 점선으로) */}\n      {showGrid &&\n        [0, 20, 40, 60, 80, 100].map((value) => {\n          const r = (value / 100) * radius; // 해당 값에 대한 반지름\n          const textOffset = 5; // 텍스트를 축에서 약간 띄울 거리\n\n          // 십자형으로 4개의 주요 방향에 값을 표기 (radian 값)\n          // 270도 (-Math.PI / 2), 0도 (0), 90도 (Math.PI / 2), 180도 (Math.PI)\n          const cardinalAngles = [\n            -Math.PI / 2, // 270도 (위)\n            0, // 0도 (오른쪽)\n            Math.PI / 2, // 90도 (아래)\n            Math.PI, // 180도 (왼쪽)\n          ];\n\n          return cardinalAngles.map((angle, angleIdx) => {\n            // 텍스트 위치 계산\n            const textX = center + (r + textOffset) * Math.cos(angle);\n            const textY = center + (r + textOffset) * Math.sin(angle);\n\n            let textAnchor = 'middle';\n            let dy = '0.35em'; // 기본 값\n\n            // 텍스트 정렬 및 위치 미세 조정\n            if (angle === 0) {\n              // 0도 (오른쪽)\n              textAnchor = 'start';\n              dy = '0.35em';\n            } else if (angle === Math.PI / 2) {\n              // 90도 (아래)\n              textAnchor = 'middle';\n              dy = '1.2em';\n            } else if (angle === Math.PI) {\n              // 180도 (왼쪽)\n              textAnchor = 'end';\n              dy = '0.35em';\n            } else if (angle === -Math.PI / 2) {\n              // 270도 (위)\n              textAnchor = 'middle';\n              dy = '-0.5em';\n            }\n\n            // 0 값은 중앙에만 표시 (가장 위쪽 축)\n            if (value === 0 && angle !== -Math.PI / 2) return null; // 0은 270도(위)에서만 표시\n\n            // 0 값의 경우 텍스트를 중심에 가깝게\n            // 0은 항상 위쪽 축에만 표시하므로, 그 위치를 고정\n            const finalTextX =\n              value === 0 && angle === -Math.PI / 2 ? center : textX;\n            const finalTextY =\n              value === 0 && angle === -Math.PI / 2 ? center + 15 : textY; // 0은 항상 중심에서 약간 아래에\n\n            return (\n              <React.Fragment key={`value-${value}-${angleIdx}`}>\n                {/* 값 텍스트 */}\n                <text\n                  x={finalTextX}\n                  y={finalTextY}\n                  textAnchor={textAnchor}\n                  dy={dy}\n                  fontSize=\"10\"\n                  fill=\"#888\"\n                >\n                  {value}\n                </text>\n\n                {/* 점선 (0이 아닌 값에 대해서만 십자형 축에 그리기) */}\n                {value !== 0 && (\n                  <line\n                    x1={center + r * Math.cos(angle)}\n                    y1={center + r * Math.sin(angle)}\n                    x2={center + (r + textOffset - 2) * Math.cos(angle)} // 텍스트 바로 앞까지\n                    y2={center + (r + textOffset - 2) * Math.sin(angle)}\n                    stroke=\"#888\" // 점선 색상\n                    strokeWidth={0.5}\n                    strokeDasharray=\"2 2\" // 점선 패턴 (2px 선, 2px 간격)\n                  />\n                )}\n              </React.Fragment>\n            );\n          });\n        })}\n    </svg>\n  );\n};\n\nexport default JewelRadarChart;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"sources":["file:///Users/jincheoljuhn/Desktop/Projects/k-laci/k-lacl-fe/k-laci/app/results/sections/CategoryRankingSection.tsx"],"sourcesContent":["'use client';\n\nimport React from 'react';\nimport CategoryRanking from '../components/CategoryRanking';\nimport { CategoryData } from '../types/category';\n\nimport JewelRadarChart from '@/atoms/charts/RadarChart';\n\nconst CategoryRankingSection = () => {\n  return (\n    <div\n      style={{\n        display: 'flex',\n        justifyContent: 'center',\n        background: '#F8F8F8',\n      }}\n    >\n      <section\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'flex-start',\n          width: '50%',\n        }}\n      >\n        {/* 타이틀 */}\n        <div\n          style={{\n            fontSize: '2.5rem',\n            fontWeight: 800,\n            paddingTop: '3rem',\n            marginBottom: '2rem',\n          }}\n        >\n          범주별 순위\n        </div>\n\n        <div style={{ width: '500px', height: '500px' }}>\n          <JewelRadarChart\n            showGrid={true}\n            data={[75, 65, 60, 70, 45, 40, 50, 46]}\n          />\n        </div>\n\n        {/* 카테고리 그리드 */}\n        {/* <div className=\"grid grid-cols-1 gap-8\">\n          {mockCategories.map((category, index) => (\n            <CategoryRanking key={index} data={category} />\n          ))}\n        </div> */}\n      </section>\n    </div>\n  );\n};\n\nconst mockCategories: CategoryData[] = [\n  {\n    title: '인구성장력',\n    color: '#F56542', // 인디고\n    currentRank: 3,\n    totalRank: 17,\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. ',\n    scores: Array(12)\n      .fill(null)\n      .map((_, i) => ({\n        indicator: `경제지표 ${i + 1}`,\n        score: Math.floor(Math.random() * 100),\n        rank: Math.floor(Math.random() * 20) + 1,\n        source: '통계청(2024)',\n      })),\n  },\n  {\n    title: '경제활동력',\n    color: '#F2BA5D', // 에메랄드\n    currentRank: 5,\n    totalRank: 17,\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. ',\n    scores: Array(12)\n      .fill(null)\n      .map((_, i) => ({\n        indicator: `사회지표 ${i + 1}`,\n        score: Math.floor(Math.random() * 100),\n        rank: Math.floor(Math.random() * 20) + 1,\n        source: '보건복지부(2024)',\n      })),\n  },\n  {\n    title: '생활기반력',\n    color: '#C2BDF3', // 앰버\n    currentRank: 7,\n    totalRank: 17,\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. ',\n    scores: Array(12)\n      .fill(null)\n      .map((_, i) => ({\n        indicator: `건강지표 ${i + 1}`,\n        score: Math.floor(Math.random() * 100),\n        rank: Math.floor(Math.random() * 20) + 1,\n        source: '질병관리청(2024)',\n      })),\n  },\n  {\n    title: '안전회복력',\n    color: '#74BF9E', // 레드\n    currentRank: 2,\n    totalRank: 17,\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. ',\n    scores: Array(12)\n      .fill(null)\n      .map((_, i) => ({\n        indicator: `만족도지표 ${i + 1}`,\n        score: Math.floor(Math.random() * 100),\n        rank: Math.floor(Math.random() * 20) + 1,\n        source: '행정안전부(2024)',\n      })),\n  },\n];\n\nexport default CategoryRankingSection;\n"],"names":[],"mappings":";;;;AAMA;AANA;;;AAQA,MAAM,yBAAyB;IAC7B,qBACE,8OAAC;QACC,OAAO;YACL,SAAS;YACT,gBAAgB;YAChB,YAAY;QACd;kBAEA,cAAA,8OAAC;YACC,OAAO;gBACL,SAAS;gBACT,eAAe;gBACf,YAAY;gBACZ,OAAO;YACT;;8BAGA,8OAAC;oBACC,OAAO;wBACL,UAAU;wBACV,YAAY;wBACZ,YAAY;wBACZ,cAAc;oBAChB;8BACD;;;;;;8BAID,8OAAC;oBAAI,OAAO;wBAAE,OAAO;wBAAS,QAAQ;oBAAQ;8BAC5C,cAAA,8OAAC,8HAAA,CAAA,UAAe;wBACd,UAAU;wBACV,MAAM;4BAAC;4BAAI;4BAAI;4BAAI;4BAAI;4BAAI;4BAAI;4BAAI;yBAAG;;;;;;;;;;;;;;;;;;;;;;AAalD;AAEA,MAAM,iBAAiC;IACrC;QACE,OAAO;QACP,OAAO;QACP,aAAa;QACb,WAAW;QACX,aACE;QACF,QAAQ,MAAM,IACX,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;gBACd,WAAW,CAAC,KAAK,EAAE,IAAI,GAAG;gBAC1B,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;gBAClC,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM;gBACvC,QAAQ;YACV,CAAC;IACL;IACA;QACE,OAAO;QACP,OAAO;QACP,aAAa;QACb,WAAW;QACX,aACE;QACF,QAAQ,MAAM,IACX,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;gBACd,WAAW,CAAC,KAAK,EAAE,IAAI,GAAG;gBAC1B,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;gBAClC,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM;gBACvC,QAAQ;YACV,CAAC;IACL;IACA;QACE,OAAO;QACP,OAAO;QACP,aAAa;QACb,WAAW;QACX,aACE;QACF,QAAQ,MAAM,IACX,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;gBACd,WAAW,CAAC,KAAK,EAAE,IAAI,GAAG;gBAC1B,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;gBAClC,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM;gBACvC,QAAQ;YACV,CAAC;IACL;IACA;QACE,OAAO;QACP,OAAO;QACP,aAAa;QACb,WAAW;QACX,aACE;QACF,QAAQ,MAAM,IACX,IAAI,CAAC,MACL,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;gBACd,WAAW,CAAC,MAAM,EAAE,IAAI,GAAG;gBAC3B,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;gBAClC,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM;gBACvC,QAAQ;YACV,CAAC;IACL;CACD;uCAEc","debugId":null}}]
}